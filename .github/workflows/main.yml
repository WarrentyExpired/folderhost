name: Create Release

on:
  workflow_dispatch:
    inputs:
      release_type:
        description: 'Release type'
        required: true
        type: choice
        options:
        - auto
        - major
        - minor
      custom_version:
        description: 'Custom version (optional, format: vYY.MM.PATCH)'
        required: false
        type: string

env:
  BINARY_NAME: folderhost

jobs:
  build-and-release:
    runs-on: ubuntu-latest
    
    outputs:
      version: ${{ steps.version.outputs.version }}
      current_date: ${{ steps.date.outputs.current_date }}
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Calculate version
      id: version
      run: |
        CURRENT_YEAR=$(date +'%y')
        CURRENT_MONTH=$(date +'%m')
        
        CURRENT_MONTH=$((10#$CURRENT_MONTH))
        
        echo "ğŸ“… Current date: Year=$CURRENT_YEAR, Month=$CURRENT_MONTH"
        
        if [[ -n "${{ github.event.inputs.custom_version }}" ]]; then
          VERSION="${{ github.event.inputs.custom_version }}"
          echo "âœï¸ Using custom version: $VERSION"
        
        elif [[ "${{ github.event.inputs.release_type }}" == "auto" ]]; then
          LATEST_TAG=$(git tag -l "v${CURRENT_YEAR}.${CURRENT_MONTH}.*" --sort=-v:refname | head -n 1)
          
          if [ -z "$LATEST_TAG" ]; then
            VERSION="v${CURRENT_YEAR}.${CURRENT_MONTH}.0"
            echo "ğŸ†• No existing tags for this month, starting with: $VERSION"
          else
            LAST_PATCH=$(echo $LATEST_TAG | awk -F. '{print $3}')
            NEW_PATCH=$((LAST_PATCH + 1))
            VERSION="v${CURRENT_YEAR}.${CURRENT_MONTH}.${NEW_PATCH}"
            echo "â¬†ï¸ Incrementing from $LATEST_TAG to $VERSION"
          fi
        
        elif [[ "${{ github.event.inputs.release_type }}" == "major" ]]; then
          EXISTING_TAG=$(git tag -l "v${CURRENT_YEAR}.${CURRENT_MONTH}.0")
          if [ -n "$EXISTING_TAG" ]; then
            echo "âš ï¸ Warning: v${CURRENT_YEAR}.${CURRENT_MONTH}.0 already exists!"
          fi
          VERSION="v${CURRENT_YEAR}.${CURRENT_MONTH}.0"
          echo "ğŸ¯ Creating new major version: $VERSION"
        
        elif [[ "${{ github.event.inputs.release_type }}" == "minor" ]]; then
          LATEST_TAG=$(git tag -l "v${CURRENT_YEAR}.${CURRENT_MONTH}.*" --sort=-v:refname | head -n 1)
          
          if [ -z "$LATEST_TAG" ]; then
            VERSION="v${CURRENT_YEAR}.${CURRENT_MONTH}.0"
            echo "ğŸ†• No existing tags for this month, starting with: $VERSION"
          else
            LAST_PATCH=$(echo $LATEST_TAG | awk -F. '{print $3}')
            NEW_PATCH=$((LAST_PATCH + 1))
            VERSION="v${CURRENT_YEAR}.${CURRENT_MONTH}.${NEW_PATCH}"
            echo "â¬†ï¸ Incrementing from $LATEST_TAG to $VERSION"
          fi
        fi

        if git rev-parse "$VERSION" >/dev/null 2>&1; then
          echo "âŒ Error: Tag $VERSION already exists!"
          exit 1
        fi

        echo "version=$VERSION" >> $GITHUB_OUTPUT
        echo "âœ… Final version: $VERSION"

    - name: Get current date
      id: date
      run: echo "current_date=$(date +'%Y-%m-%d %H:%M:%S UTC')" >> $GITHUB_OUTPUT

    - name: Setup Go
      uses: actions/setup-go@v5
      with:
        go-version: '1.21'

    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '20'

    - name: Install Mingw for Windows cross-compilation
      run: |
        sudo apt-get update
        sudo apt-get install -y gcc-mingw-w64

    - name: Install dependencies
      run: make setup

    - name: Build for Linux and Windows
      run: make build

    - name: Create release packages
      run: |
        mkdir -p ./release_packages
        
        # Linux package
        cp ./debug/${{ env.BINARY_NAME }} ./${{ env.BINARY_NAME }}
        chmod +x ./${{ env.BINARY_NAME }}
        zip -j ./release_packages/folderhost-linux-amd64.zip ./${{ env.BINARY_NAME }}
        rm ./${{ env.BINARY_NAME }}
        echo "âœ… Linux package created"
        
        # Windows package
        cp ./debug/${{ env.BINARY_NAME }}.exe ./${{ env.BINARY_NAME }}.exe
        zip -j ./release_packages/folderhost-windows-amd64.zip ./${{ env.BINARY_NAME }}.exe
        rm ./${{ env.BINARY_NAME }}.exe
        echo "âœ… Windows package created"

    - name: Verify packages
      run: |
        echo "ğŸ“¦ Release packages:"
        ls -lh ./release_packages/
        echo ""
        echo "ğŸ“Š Package sizes:"
        du -h ./release_packages/*

    - name: Upload artifacts
      uses: actions/upload-artifact@v4
      with:
        name: release-packages
        path: ./release_packages/

  build-docker:
    runs-on: ubuntu-latest
    needs: build-and-release
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3

    - name: Log in to DockerHub
      uses: docker/login-action@v3
      with:
        username: ${{ secrets.DOCKERHUB_USERNAME }}
        password: ${{ secrets.DOCKERHUB_TOKEN }}

    - name: Extract metadata
      id: meta
      uses: docker/metadata-action@v5
      with:
        images: ${{ secrets.DOCKERHUB_USERNAME }}/folderhost
        tags: |
          type=raw,value=${{ needs.build-and-release.outputs.version }}
          type=raw,value=latest

    - name: Build and push Docker image
      uses: docker/build-push-action@v5
      with:
        context: .
        file: ./Dockerfile.prod
        push: true
        tags: ${{ steps.meta.outputs.tags }}
        labels: ${{ steps.meta.outputs.labels }}
        platforms: linux/amd64
        cache-from: type=gha
        cache-to: type=gha,mode=max

    - name: Docker image info
      run: |
        echo "ğŸ‹ Docker image pushed successfully!"
        echo "ğŸ“ Image: ${{ secrets.DOCKERHUB_USERNAME }}/folderhost:${{ needs.build-and-release.outputs.version }}"
        echo "ğŸ“ Latest: ${{ secrets.DOCKERHUB_USERNAME }}/folderhost:latest"

  create-release:
    runs-on: ubuntu-latest
    needs: [build-and-release, build-docker]

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Download artifacts
      uses: actions/download-artifact@v4
      with:
        name: release-packages
        path: ./release_packages/

    - name: Create Release
      uses: softprops/action-gh-release@v2
      with:
        tag_name: ${{ needs.build-and-release.outputs.version }}
        name: Release ${{ needs.build-and-release.outputs.version }}
        body: |
          ğŸš€ **Folderhost Release ${{ needs.build-and-release.outputs.version }}**
          
          ğŸ“… Release Date: ${{ needs.build-and-release.outputs.current_date }}
          
          ## ğŸ“¦ Downloads
          
          | Platform | Download | Description |
          |----------|----------|-------------|
          | ğŸ§ Linux | [`folderhost-linux-amd64.zip`](https://github.com/${{ github.repository }}/releases/download/${{ needs.build-and-release.outputs.version }}/folderhost-linux-amd64.zip) | Linux x86_64 binary |
          | ğŸªŸ Windows | [`folderhost-windows-amd64.zip`](https://github.com/${{ github.repository }}/releases/download/${{ needs.build-and-release.outputs.version }}/folderhost-windows-amd64.zip) | Windows x86_64 executable |
          | ğŸ‹ Docker | `docker pull ${{ secrets.DOCKERHUB_USERNAME }}/folderhost:${{ needs.build-and-release.outputs.version }}` | Docker image |
          
          ## ğŸ‹ Docker Usage
          
          ```bash
          # Pull the image
          docker pull ${{ secrets.DOCKERHUB_USERNAME }}/folderhost:${{ needs.build-and-release.outputs.version }}
          
          # Or use latest
          docker pull ${{ secrets.DOCKERHUB_USERNAME }}/folderhost:latest
          
          # Run with docker-compose
          # Download docker-compose.prod.yml from repository
          docker-compose -f docker-compose.prod.yml up -d
          ```
          
          **Important:** The application will use port 5000 by default, but you can change this in `config.yml` and update the port mapping in `docker-compose.prod.yml` accordingly.
          
          ## ğŸ”§ Quick Start
          
          ### Linux
          ```bash
          # Download and extract
          wget https://github.com/${{ github.repository }}/releases/download/${{ needs.build-and-release.outputs.version }}/folderhost-linux-amd64.zip
          unzip folderhost-linux-amd64.zip
          chmod +x folderhost
          
          # Run
          ./folderhost
          ```
          
          ### Windows
          ```powershell
          # Download, extract, and run
          # Edit config.yml as needed
          folderhost.exe # Or just double click
          ```
          
          ### Docker
          ```bash
          # Create necessary files and directories
          touch config.yml database.db
          mkdir -p recovery_bin testdir
          
          # Run container
          docker run -d \
            --name folderhost \
            -p 5000:5000 \
            -v $(pwd)/config.yml:/app/config.yml \
            -v $(pwd)/database.db:/app/database.db \
            -v $(pwd)/recovery_bin:/app/recovery_bin \
            -v $(pwd)/testdir:/app/testdir \
            ${{ secrets.DOCKERHUB_USERNAME }}/folderhost:${{ needs.build-and-release.outputs.version }}
          ```
          
          ## âš™ï¸ Manual Configuration
          
          1. Extract the downloaded archive (for binary installations)
          2. Run the application once to generate `config.yml`
          3. Edit `config.yml` to customize settings (especially the port if needed)
          4. For Docker: Update the port mapping in `docker-compose.prod.yml` if you changed the port in `config.yml`
          5. Restart the application
          
          ---
          
          ğŸ’¡ For issues and questions, please visit the [GitHub Issues](https://github.com/${{ github.repository }}/issues) page.
        files: |
          ./release_packages/folderhost-linux-amd64.zip
          ./release_packages/folderhost-windows-amd64.zip
        draft: false
        prerelease: false
        generate_release_notes: true
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

    - name: Release summary
      run: |
        echo "ğŸ‰ Release ${{ needs.build-and-release.outputs.version }} created successfully!"
        echo "ğŸ“ URL: https://github.com/${{ github.repository }}/releases/tag/${{ needs.build-and-release.outputs.version }}"
        echo "ğŸ‹ Docker: ${{ secrets.DOCKERHUB_USERNAME }}/folderhost:${{ needs.build-and-release.outputs.version }}"